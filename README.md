# Shwifty

## Generate Swift types from Haskell types

Examples: 

```haskell
-- A simple sum type
data SumType = Sum1 | Sum2 | Sum3
getShwifty ''SumType
```

```swift
enum SumType {
    case sum1
    case sum2
    case sum3
}
```

```haskell
-- A simple product type
data ProductType = ProductType { x :: Int, y :: Int }
getShwifty ''ProductType
```

```swift
struct ProductType {
    let x: Int
    let y: Int
}
```

```haskell
-- A sum type with type variables
data SumType a b = SumL a | SumR b
getShwifty ''SumType
```

```swift
enum SumType<A, B> {
    case sumL(A)
    case sumR(B)
}
```

```haskell
-- A product type with type variables
data ProductType a b = ProductType { aField :: a, bField :: b }
getShwifty ''ProductType
```

```swift
struct ProductType<A, B> {
    let aField: A
    let bField: B
}
```

```haskell
-- A newtype
newtype Newtype a = Newtype { getNewtype :: a }
getShwifty ''Newtype
```

```swift
struct Newtype<A> {
    let getNewtype: A
}
```

```haskell
-- A type with a function field
newtype Endo a = Endo { appEndo :: a -> a }
getShwifty ''Endo
```

```swift
struct Endo<A> {
    let appEndo: ((A) -> A)
}
```

```haskell
-- A weird type with nested fields. Also note the Result's types being flipped from that of the Either.
data YouveGotProblems a b = YouveGotProblems { field1 :: Maybe (Maybe (Maybe a)), field2 :: Either (Maybe a) (Maybe b) }
getShwifty ''YouveGotProblems
```

```swift
struct YouveGotProblems<A, B> {
    let field1: Option<Option<Option<A>>>
    let field2: Result<Option<B>,Option<A>>
}
```

```haskell
-- A type with polykinded type variables
data PolyKinded (a :: k) = PolyKinded
getShwifty ''PolyKinded
```

```swift
struct PolyKinded<A> {
}
```

```haskell
-- A sum type where constructors might be records
data SumType a b (c :: k) = Sum1 Int a (Maybe b) | Sum2 b | Sum3 { x :: Int, y :: Int }
getShwifty ''SumType
```

```swift
enum SumType<A, B, C> {
  case field1(Int, A, Optional<B>)
  case field2(B)
  case field3(_ x: Int, _ y: Int)
}
```

```haskell
-- A type containing another type with instance generated by 'getShwifty'
newtype MyFirstType a = MyFirstType { getMyFirstType :: a }
getShwifty ''MyFirstType

data Contains a = Contains { x :: MyFirstType Int, y :: MyFirstType a }
getShwifty ''Contains
```

```swift
struct MyFirstType<A> {
  let getMyFirstType: A
}

struct Contains<A> {
  let x: MyFirstType<Int>
  let y: MyFirstType<A>
}
```
